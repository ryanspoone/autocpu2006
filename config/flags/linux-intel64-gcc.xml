<?xml version="1.0"?>
<!DOCTYPE flagsdescription SYSTEM "http://www.spec.org/dtd/cpuflags2.dtd">
<flagsdescription>

<filename>linux-intel64-gcc</filename>

<title>Intel64 GCC SPEC CPU2006 Flags</title>

<submit_command>
<![CDATA[
<p><b>Using numactl to bind processes and memory to cores</b></p>
<p>For multi-copy runs or single copy runs on systems with multiple sockets, it is advantageous to bind a process to a particular core.  Otherwise, the OS may arbitrarily move your process from one core to another.  This can effect perf$
<p>numactl runs processes with a specific NUMA scheduling or memory placement policy.  The policy is set for a command and inherited by all of its children.  The numactl flag "--physcpubind" specifies which core(s) to bind the process. $
<p>Note that some versions of numactl, particularly the version found on SLES 10, we have found that the utility incorrectly interprets application arguments as it's own.  For example, with the command "numactl --physcpubind=0 -l a.out $
]]>
</submit_command>

<sw_environment>
<![CDATA[
<p><b> ulimit -s &lt;n&gt;</b></p>
<p>      Sets the stack size to <b>n</b> kbytes, or <b>unlimited</b> to allow the stack size      to grow without limit.
</p>
]]>
</sw_environment>

<header>
<![CDATA[
<p>Compilers: gcc 4.8</p>
<p>Compilers: gcc 4.9</p>
<p>Compilers: gcc 5.0</p>
<p>Compilers: gcc 5.1</p>
<p>Compilers: gcc 5.2</p>

<p>This file contains information about the GNU gcc compiler, reformatted for
SPEC result reporting, excerpted and/or summarized from the GNU documentation
and from Linux's man pages.</p>

<p>The Copyright notice from the gcc.gnu.org online docs:<br />
Copyright (c) 1988-2016 Free Software Foundation, Inc.</p>

<p>SPEC's modifications are:<br />
Copyright (C) 2006-2011 Standard Performance Evaluation Corporation</p>

<p>Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.2 or any later
version published by the Free Software Foundation; with the Invariant Sections
being "GNU General Public License" "Funding Free Software", the Front-Cover
texts being (a) (see below), and with the Back-Cover Texts being (b) (see
below).  A copy of the license is included on your SPEC media as
<tt>redistributable_sources/licences/fdl-1.2.txt</tt> 
<br />and the "Funding Free Software" section is on your SPEC media as
<br /><tt>redistributable_sources/licences/fsf-funding.txt</tt></p>

<p>(a) The FSF's Front-Cover Text is:</p>

     <p style="margin-left:3em;">A GNU Manual</p>

<p>(b) The FSF's Back-Cover Text is:</p>

<p style="margin-left:3em;">You have freedom to copy and modify this GNU Manual,
like GNU software.  Copies published by the Free Software Foundation raise funds
for GNU development.</p>
]]>
</header>

<flag name="gcc" class="compiler" regexp="(?:/\S+/)?gcc\b">
<example>gcc</example>
<![CDATA[
<p>
Invoke a Linux distribution's modified version of the GCC C compiler, or one direct from FSF.
</p>
]]>
</flag>
<flag name="CC" class="compiler" regexp="(?:/\S+/)?g\+\+(?=\s|$)">
<example>gcc</example>
Invoke a Linux distribution's modified version of the GCC C compiler, or one direct from FSF.
</flag>

<flag name="CXX" class="compiler" regexp="(?:/\S+/)?g\+\+(?=\s|$)">
<example>g++</example>
Invoke a Linux distribution's modified version of the GCC C++ compiler, or one direct from FSF.
</flag>

<flag name="FC" class="compiler" regexp="(?:/\S+/)?gfortran\b">
<example>gfortran</example>
Invoke a Linux distribution's modified version of the GCC fortran compiler, or one direct from FSF.
</flag>

<flag name="F77" class="compiler" regexp="(?:/\S+/)?gfortran\b">
<example>gfortran</example>
Invoke a Linux distribution's modified version of the GCC fortran compiler, or one direct from FSF.
</flag>

<flag name="F-O0" class="optimization">
<example>-O0</example>
<![CDATA[
<p>Do not optimize. This is the default.</p>
]]>
</flag>

<flag name="F-O1" class="optimization">
<example>-O</example>
<example>-O1</example>
<![CDATA[
<p>Optimize. Optimizing compilation takes somewhat more time, and a lot more
memory for a large function.</p>

<p>With -O, the compiler tries to reduce code size and execution time, without
performing any optimizations that take a great deal of compilation time.</p>

<p>-O turns on the following optimization flags:</p>
<ul>
<li>-fdefer-pop</li>
<li>-fdelayed-branch</li>
<li>-fguess-branch-probability</li>
<li>-fcprop-registers</li>
<li>-floop-optimize</li>
<li>-fif-conversion</li>
<li>-fif-conversion2</li>
<li>-ftree-ccp</li>
<li>-ftree-dce</li>
<li>-ftree-dominator-opts</li>
<li>-ftree-dse</li>
<li>-ftree-ter</li>
<li>-ftree-lrs</li>
<li>-ftree-sra</li>
<li>-ftree-copyrename</li>
<li>-ftree-fre</li>
<li>-ftree-ch</li>
<li>-fmerge-constants</li>
</ul>

<p>-O also turns on -fomit-frame-pointer on machines where doing so does not 
interfere with debugging.</p>
]]>
<include flag="F-fdefer-pop" />
<include flag="F-fdelayed-branch" />
<include flag="F-fguess-branch-probability" />
<include flag="F-fcprop-registers" />
<include flag="F-floop-optimize" />
<include flag="F-fif-conversion" />
<include flag="F-fif-conversion2" />
<include flag="F-ftree-ccp" />
<include flag="F-ftree-dce" />
<include flag="F-ftree-dominator-opts" />
<include flag="F-ftree-dse" />
<include flag="F-ftree-ter" />
<include flag="F-ftree-lrs" />
<include flag="F-ftree-sra" />
<include flag="F-ftree-copyrename" />
<include flag="F-ftree-fre" />
<include flag="F-ftree-ch" />
<include flag="F-fmerge-constants" />
</flag>

<flag name="F-O2" class="optimization">
<example>-O2</example>
<![CDATA[
<p>Optimize even more. GCC performs nearly all supported optimizations that do 
not involve a space-speed tradeoff. The compiler does not perform loop 
unrolling or function inlining when you specify -O2. As compared to -O, this 
option increases both compilation time and the performance of the generated 
code.</p>

<p>-O2 turns on all optimization flags specified by -O. It also turns on the 
following optimization flags:</p>
<ul>
<li>-fthread-jumps</li>
<li>-fcrossjumping</li>
<li>-foptimize-sibling-calls</li>
<li>-fcse-follow-jumps</li>
<li>-fcse-skip-blocks</li>
<li>-fgcse</li>
<li>-fgcse-lm</li>
<li>-fexpensive-optimizations</li>
<li>-fstrength-reduce</li>
<li>-frerun-cse-after-loop</li>
<li>-frerun-loop-opt</li>
<li>-fcaller-saves</li>
<li>-fpeephole2</li>
<li>-fschedule-insns</li>
<li>-fschedule-insns2</li>
<li>-fsched-interblock</li>
<li>-fsched-spec</li>
<li>-fregmove</li>
<li>-fstrict-aliasing</li>
<li>-fdelete-null-pointer-checks</li>
<li>-freorder-blocks</li>
<li>-freorder-functions</li>
<li>-funit-at-a-time</li>
<li>-falign-functions</li>
<li>-falign-jumps</li>
<li>-falign-loops</li>
<li>-falign-labels</li>
<li>-ftree-vrp</li>
<li>-ftree-pre</li>
</ul>
]]>
<include flag="F-fthread-jumps" />
<include flag="F-fcrossjumping" />
<include flag="F-foptimize-sibling-calls" />
<include flag="F-fcse-follow-jumps" />
<include flag="F-fcse-skip-blocks" />
<include flag="F-fgcse" />
<include flag="F-fgcse-lm" />
<include flag="F-fexpensive-optimizations" />
<include flag="F-fstrength-reduce" />
<include flag="F-frerun-cse-after-loop" />
<include flag="F-frerun-loop-opt" />
<include flag="F-fcaller-saves" />
<include flag="F-fpeephole2" />
<include flag="F-fschedule-insns" />
<include flag="F-fschedule-insns2" />
<include flag="F-fsched-interblock" />
<include flag="F-fsched-spec" />
<include flag="F-fregmove" />
<include flag="F-fstrict-aliasing" />
<include flag="F-fdelete-null-pointer-checks" />
<include flag="F-freorder-blocks" />
<include flag="F-freorder-functions" />
<include flag="F-funit-at-a-time" />
<include flag="F-falign-functions" />
<include flag="F-falign-jumps" />
<include flag="F-falign-loops" />
<include flag="F-falign-labels" />
<include flag="F-ftree-vrp" />
<include flag="F-O1" />
</flag>

<flag name="F-O3" class="optimization">
<example>-O3</example>
<![CDATA[
<p>Optimize yet more. -O3 turns on all optimizations specified by -O2 and also turns on the -finline-functions, -funswitch-loops and -fgcse-after-reload options.</p>
]]>
<include flag="F-finline-functions" />
<include flag="F-funswitch-loops" />
<include flag="F-fgcse-after-reload" />
<include flag="F-O2" />
</flag>

<flag name="F-Ofast" class="optimization">
<example>-Ofast</example>
<![CDATA[
<p>Disregard strict standards compliance. -Ofast enables all -O3 optimizations. It also enables optimizations that are not valid for all standard-compliant programs. It turns on -ffast-math and the Fortran-specific -fno-protect-parens and -fstack-arrays.</p>
]]>
<include flag="F-fstack-arrays" />
<include flag="F-fno-protect-parens" />
<include flag="F-ffast-math" />
<include flag="F-O3" />
</flag>

<flag name="F-mtune" class="optimization" regexp="-mtune=(\S+)\b">
<example>-mtune=cpu-type</example>
<![CDATA[
<p>Tune to cpu-type everything applicable about the generated code, except for the ABI and the set of available instructions. While picking a specific cpu-type schedules things appropriately for that particular chip, the compiler does not generate any code that cannot run on the default machine type unless you use a -march=cpu-type option. For example, if GCC is configured for i686-pc-linux-gnu then -mtune=pentium4 generates code that is tuned for Pentium 4 but still runs on i686 machines.</p>

<p>The choices for cpu-type are the same as for -march. In addition, -mtune supports 2 extra choices for cpu-type:</p>

<ul>
<li>generic</li>
<li>intel</li>
</ul>
]]>
</flag>

<flag name="F-march" class="optimization" regexp="-march=(\S+)\b">
<example>-march=cpu-type</example>
<![CDATA[
<p>Generate instructions for the machine type cpu-type. In contrast to -mtune=cpu-type, which merely tunes the generated code for the specified cpu-type, -march=cpu-type allows GCC to generate code that may not run at all on processors other than the one indicated. Specifying -march=cpu-type implies -mtune=cpu-type.</p>

<p>The choices for cpu-type are:</p>

<ul>
<li>native</li>
<li>i386</li>
<li>i486</li>
<li>i586</li>
<li>pentium</li>
<li>pentium-mmx</li>
<li>pentiumpro</li>
<li>i686</li>
<li>pentium2</li>
<li>pentium3</li>
<li>pentium3m</li>
<li>pentium-m</li>
<li>pentium4</li>
<li>pentium4m</li>
<li>prescott</li>
<li>nocona</li>
<li>core2</li>
<li>nehalem</li>
<li>westmere</li>
<li>sandybridge</li>
<li>ivybridge</li>
<li>haswell</li>
<li>broadwell</li>
<li>bonnell</li>
<li>silvermont</li>
<li>knl</li>
<li>k6</li>
<li>k6-2</li>
<li>k6-3</li>
<li>athlon</li>
<li>athlon-tbird</li>
<li>athlon-4</li>
<li>athlon-xp</li>
<li>athlon-mp</li>
<li>k8</li>
<li>opteron</li>
<li>athlon64</li>
<li>athlon-fx</li>
<li>k8-sse3</li>
<li>opteron-sse3</li>
<li>athlon64-sse3</li>
<li>amdfam10</li>
<li>barcelona</li>
<li>bdver1</li>
<li>bdver2</li>
<li>bdver3</li>
<li>bdver4</li>
<li>btver1</li>
<li>btver2</li>
<li>winchip-c6</li>
<li>winchip2</li>
<li>c3</li>
<li>c3-2</li>
<li>geode</li>
</ul>
]]>
</flag>

<!-- ======================================================================
     ======================================================================
     At this point we're to all of the "subordinate" flags; that is, flags
     that are only referenced indirectly.  There is NO technical reason that
     these flags must be segregated.  I'm only doing it here because
     initially the flags above (sans includes) were the only ones I had
     described.  (I used to use this flags file for some of my test runs.)

     Also, the comments will start to thin out; I've already covered all of
     the basics.
     ======================================================================
     ====================================================================== -->

<flag name="F-falign-functions" class="optimization">
<example>
-falign-functions,
-falign-functions=n
</example>
<![CDATA[
<p>Align the start of functions to the next power-of-two greater than
   <i>n</i>, skipping up to <i>n</i> bytes.  For instance,
   <tt>-falign-functions=32</tt> aligns functions to the next 32-byte
   boundary, but <tt>-falign-functions=24</tt> would align to the next
   32-byte boundary only if this can be done by skipping 23 bytes or less.</p>

<p><tt>-fno-align-functions</tt> and <tt>-falign-functions=1</tt> are
   equivalent and mean that functions will not be aligned.</p>

<p>Some assemblers only support this flag when <i>n</i> is a power of two; in
   that case, it is rounded up.</p>

<p>If <i>n</i> is not specified, use a machine-dependent default.</p>
]]>
</flag>

<flag name="F-falign-loops" class="optimization">
<example>
-falign-loops,
-falign-loops=n
</example>
<![CDATA[
<p>Align loops to a power-of-two boundary, skipping up to <i>n</i> bytes like
   <tt>-falign-functions.</tt>  The hope is that the loop will be executed
   many times, which will make up for any execution of the dummy
   operations.</p>
]]>
</flag>

<flag name="F-falign-loops-max-skip" class="optimization">
<example>
-falign-loops-max-skip,
-falign-loops-max-skip=n
</example>
<![CDATA[
<p>When aligning loops to a power-of-two boundary, only do so if can skip by
   up to <i>n</i> bytes.</p>

<p>If <i>n</i> is not specified, use a machine-dependent default.</p>
]]>
</flag>

<flag name="F-falign-jumps" class="optimization">
<example>
-falign-jumps,
-falign-jumps=n
</example>
<![CDATA[
<p>Align branch targets to a power-of-two boundary, for branch targets
    where the targets can only be reached by jumping, skipping up to <i>n</i>
    bytes like <tt>-falign-functions.</tt>  In this case, no dummy operations
    need be executed.</p>
]]>
</flag>

<flag name="F-falign-jumps-max-skip" class="optimization">
<example>
-falign-jumps-max-skip,
-falign-jumps-max-skip=n
</example>
<![CDATA[
<p>When aligning branch targets to a power-of-two boundary, only do so
   if can skip by up to <i>n</i> bytes.</p>

<p>If <i>n</i> is not specified, use a machine-dependent default.</p>
]]>
</flag>

<flag name="F-force_cpusubtype_ALL" class="optimization">
<example>
-force_cpusubtype_ALL
</example>
<![CDATA[
<p>Hey!  What does this flag do?  It's not in the man page.</p>
<p>Well, I know that <strong>you</strong>, as the well informed and well-
   connected (with your compiler vendor) will be able to document ALL of
   your implicitly included flags.</p>
]]>
</flag>

<flag name="F-fsched-interblock" class="optimization">
<example>
-fsched-interblock
</example>
<![CDATA[
<p>Schedule instructions across basic blocks.  This is enabled by default when
scheduling before register allocation, i.e. with <tt>-fschedule-insns</tt> or  
at <tt>-O2</tt> or higher.</p>
]]>
</flag>

<flag name="F-fstrict-aliasing" class="optimization">
<example>
-fstrict-aliasing
</example>
<![CDATA[
<p>Allows the compiler to assume the strictest aliasing rules applicable to
   the language being compiled.  For C (and C++), this activates optimizations
   based on the type of expressions.  In particular, an object of one type is
   assumed never to reside at the same address as an object of a different
   type, unless the types are almost the same.  For example, an "unsigned int"
   can alias an "int", but not a "void*" or a "double".  A character type may
   alias any other type.</p>

<p>Pay special attention to code like this:</p>
<pre>
   union a_union {
     int i;
     double d;
   };

   int f() {
     a_union t;
     t.d = 3.0;
     return t.i;
   }
</pre>

<p>The practice of reading from a different union member than the one
   most recently written to (called ``type-punning'') is common.  Even
   with <tt>-fstrict-aliasing</tt>, type-punning is allowed, provided the
   memory is accessed through the union type.  So, the code above will
   work as expected.  However, this code might not:</p>
<pre>
   int f() {
     a_union t;
     int* ip;
     t.d = 3.0;
     ip = &amp;t.i;
     return *ip;
   }
</pre>
]]>
</flag>

<flag name="F-fno-second-underscore" class="other">
<example>
-fno-second-underscore
</example>
<![CDATA[
  Fortran appends an underscore to external
  names.  If this option is not used, \s-1GNU\s0 Fortran appends two
  underscores to names with underscores and one underscore to external names
  with no underscores.  \s-1GNU\s0 Fortran also appends two underscores to
  internal names with underscores to avoid naming collisions with external
  names. With this option the second underscore is not used.
]]>
</flag>

<flag name="F-fno-strict-aliasing" class="optimization">
<example>
-fno-strict-aliasing
</example>
<![CDATA[
<p>Does not allow the compiler to assume the strictest aliasing rules applicable to
   the language being compiled.  For C (and C++), optimizations
   based on the type of expressions are not activated.</p>
]]>
</flag>

<flag name="F-funroll-loops" class="optimization">
<example>
-funroll-loops
</example>
<![CDATA[
<p>Unroll loops whose number of iterations can be determined at compile time
   or upon entry to the loop.  <tt>-funroll-loops</tt> implies both
   <tt>-fstrength-reduce</tt> and <tt>-frerun-cse-after-loop</tt>.  This
   option makes code larger, and may or may not make it run faster.</p>
]]>
<include flag="F-fstrength-reduce" />
<include flag="F-frerun-cse-after-loop" />
</flag>

<flag name="F-ffast-math" class="optimization">
<example>
-ffast-math
</example>
<![CDATA[
<p>Sets the following flags:</p>
<ul>
  <li>-fno-math-errno       </li>
  <li>-funsafe-math-optimizations</li>
  <li>-fno-trapping-math    </li>
  <li>-ffinite-math-only    </li>
  <li>-fno-signaling-nans   </li>
</ul>
]]>
<include flag="F-fno-math-errno" />
<include flag="F-funsafe-math-optimizations" />
<include flag="F-fno-trapping-math" />
<include flag="F-ffinite-math-only" />
<include flag="F-fno-signaling-nans" />
</flag>

<!-- How did the next flag get so simple? We've defaulted both the 
     regexp and the example from the name; and the description is simple
     enough not to need HTML.  Sections 2.3.1, 3.3.1 and 3.7 -->

<flag name="F-malign-natural" class="optimization">
Aligns larger data types such as doubles on their natural boundaries.
</flag>

<flag name="F-mdynamic-no-pic" class="optimization">
   Compile code so that it is not relocatable, but that its external
   references are relocatable.  The resulting code is suitable for
   applications, but not shared libraries.
</flag>

<flag name="F-fno-trapping-math" class="optimization">
<![CDATA[
<p>Compile code assuming that floating-point operations cannot generate
user-visible traps.  These traps include division by zero, overflow,
underflow, inexact result and invalid operation.  This option implies
<tt>-fno-signaling-nans</tt>.  Setting this option may allow faster code
if one relies on `non-stop' IEEE arithmetic, for example.</p>

<p>Use of this option can result in incorrect output for programs which
   depend on an exact implementation of IEEE or ISO rules/specifications for
   math functions.</p>
]]>
<include flag="F-fno-signaling-nans" />
</flag>

<flag name="F-fno-signaling-nans" class="optimization">
Compile code assuming that IEEE signaling NaNs may not generate
user-visible traps during floating-point operations.  Setting this
option enabled optimizations that may change the number of exceptions
visible with signaling NaNs.
</flag>

<flag name="F-funsafe-math-optimizations" class="optimization">
<![CDATA[
<p>Allow optimizations for floating-point arithmetic that
(a) assume that arguments and results are valid and (b) may violate  
IEEE or ANSI standards.  When used at link-time, it may include  
libraries or startup files that change the default FPU control  
word or other similar optimizations.</p>

<p>Use of this option may result in incorrect output for programs which
   depend on an exact implementation of IEEE or ISO rules/specifications
   for math functions.</p>
]]>
</flag>

<flag name="F-ffinite-math-only" class="optimization">
<![CDATA[
<p>Allow optimizations for floating-point arithmetic that assume that
   arguments and results are not NaNs or +-Infs.</p>

<p>Use of this option may result in incorrect output for programs which
   depend on an exact implementation of IEEE or ISO rules/specifications
   for math functions.</p>
]]>
</flag>

<flag name="F-fno-math-errno" class="optimization">
<![CDATA[
<p>Do not set ERRNO after calling math functions that are executed
   with a single instruction, e.g., sqrt.  A program that relies on
   IEEE exceptions for math error handling may want to use this flag
   for speed while maintaining IEEE arithmetic compatibility.</p>

<p>Use of this option may result in incorrect output for programs which
   depend on an exact implementation of IEEE or ISO rules/specifications
   for math functions.</p>
]]>
</flag>

<flag name="F-frerun-cse-after-loop" class="optimization">
<![CDATA[
<p>   Re-run common subexpression elimination after loop optimizations
   have been performed.
</p>
]]>
</flag>

<flag name="F-finline-functions" class="optimization">
<![CDATA[
<p>Integrate all simple functions into their callers.  The compiler
   heuristically decides which functions are simple enough to be worth
   integrating in this way.</p>

<p>If all calls to a given function are integrated, and the function
   is declared "static", then the function is normally not output as
   assembler code in its own right.</p>
]]>
</flag>

<flag name="F-fno-inline-functions" class="optimization">
<![CDATA[
<p>Do not integrate all simple functions into their callers.  The compiler
   heuristically decides which functions are simple enough to be worth
   integrating in this way.</p>

<p>If all calls to a given function are integrated, and the function
   is declared "static", then the function is normally not output as
   assembler code in its own right.</p>
]]>
</flag>

<flag name="F-frename-registers" class="optimization">
   Attempt to avoid false dependencies in scheduled code by making use
   of registers left over after register allocation.  This optimization will
   most benefit processors with lots of registers.  It can, however, make
   debugging impossible, since variables will no longer stay in a `home
   register'.
</flag>

<flag name="F-fgcse-after-reload" class="optimization">
<![CDATA[
<p>When -fgcse-after-reload is enabled, a redundant load elimination pass is 
performed after reload. The purpose of this pass is to cleanup redundant 
spilling.</p>
]]>
</flag>

<flag name="F-funsigned-char" class="other">
<![CDATA[
<p> 
Let the type `char' be unsigned, like `unsigned char'.
Each kind of machine has a default for what `char' should be.  It
is either like `unsigned char' by default or like `signed char' by
default.
Ideally, a portable program should always use `signed char' or
`unsigned char' when it depends on the signedness of an object.
But many programs have been written to use plain `char' and expect
it to be signed, or expect it to be unsigned, depending on the
machines they were written for.  This option, and its inverse, let
you make such a program work with the opposite default.
The type `char' is always a distinct type from each of `signed
char' or `unsigned char', even though its behavior is always just
like one of those two.
</p>
]]>
</flag>


<flag name="F-fsigned-char" class="other">
<![CDATA[
<p> 
Let the type `char' be signed, like `signed char'.
Each kind of machine has a default for what `char' should be.  It
is either like `signed char' by default or like `unsigned char' by
default.
Ideally, a portable program should always use `signed char' or
`unsigned char' when it depends on the signedness of an object.
But many programs have been written to use plain `char' and expect
it to be signed, or expect it to be unsigned, depending on the
machines they were written for.  This option, and its inverse, let
you make such a program work with the opposite default.
The type `char' is always a distinct type from each of `signed
char' or `unsigned char', even though its behavior is always just
like one of those two.
</p>
]]>
</flag>

<flag name="F-include" class="portability" regexp="-include(\s+)([a-z]+)">
<![CDATA[
<p> 
Process FILE as if `#include "file"' appeared as the first line of
the primary source file.  However, the first directory searched
for FILE is the preprocessor's working directory _instead of_ the
directory containing the main source file.  If not found there, it
is searched for in the remainder of the `#include "..."' search
chain as normal.

If multiple `-include' options are given, the files are included
in the order they appear on the command line.</p>

]]>
</flag>

<flag name="F-DSPEC_CPU_ENABLE_FORTRAN_TO_C" class="other" >
<![CDATA[
Deprecated define from the SPEC CPU2006 development kits. It was accidentally left in the benchmark runs. 
This is not defined anywhere in the benchmark code and does not affect reproducibility of the results.
]]>
</flag>


<flag name="F-funswitch-loops" class="optimization">
<![CDATA[
<p>Move branches with loop invariant conditions out of the loop, with 
duplicates of the loop on both branches (modified according to result 
of the condition).</p>
]]>
</flag>

<flag name="F-m32" class="other">
<example>
-m32
</example>
<![CDATA[
<p>Generate code for a 32-bit environment. The 32-bit environment sets int, long and pointer to 32 bits and generates code that runs on any i386 system.</p>
]]>
</flag>

<flag name="F-m64" class="other">
<example>
-m64
</example>
<![CDATA[
<p>Generate code for a 64-bit environment. The 64-bit environment sets int to 32 bits, and long and pointer to 64 bits and generates code that runs on any x86-64 system.</p>
]]>
</flag>

<flag name="F-fdefer-pop" class="optimization">
<![CDATA[
<p> Always pop the arguments to each function call as soon as that function returns. 
For machines which must pop arguments after a function call, the compiler 
normally lets arguments accumulate on the stack for several function calls 
and pops them all at once.

-fnodefer-pop is disabled at levels -O, -O2, -O3, -Os.  </p>
]]>
</flag>

<flag name="F-fdelayed-branch" class="optimization">
<![CDATA[
<p>If supported for the target machine, attempt to reorder instructions to 
exploit instruction slots available after delayed branch instructions.

Enabled at levels -O, -O2, -O3, -Os.  </p>
]]>
</flag>

<flag name="F-fguess-branch-probability" class="optimization">
<![CDATA[
<p>If supported for the target machine, attempt to reorder instructions to exploit 
instruction slots available after delayed branch instructions.

-fnoguess-branch-probability is enabled at levels -O, -O2, -O3, -Os.  </p>
]]>
</flag>

<flag name="F-fcprop-registers" class="optimization">
<![CDATA[
<p>After register allocation and post-register allocation instruction 
splitting, we perform a copy-propagation pass to try to reduce scheduling 
dependencies and occasionally eliminate the copy.

-fno-cprop-registers is disabled at levels -O, -O2, -O3, -Os.  </p>
]]>
</flag>

<flag name="F-floop-optimize" class="optimization">
<![CDATA[
<p>Perform loop optimizations: move constant expressions out of loops, 
simplify exit test conditions and optionally do strength-reduction as well.

Enabled at levels -O, -O2, -O3, -Os.  </p>
]]>
</flag>

<flag name="F-fif-conversion" class="optimization">
<![CDATA[
<p>Attempt to transform conditional jumps into branch-less equivalents. 
This include use of conditional moves, min, max, set flags and abs instructions, 
and some tricks doable by standard arithmetics. The use of conditional 
execution on chips where it is available is controlled by if-conversion2.

Enabled at levels -O, -O2, -O3, -Os.  </p>
]]>
</flag>

<flag name="F-fif-conversion2" class="optimization">
<![CDATA[
<p>Use conditional execution (where available) to transform conditional 
jumps into branch-less equivalents.

Enabled at levels -O, -O2, -O3, -Os.  </p>
]]>
</flag>

<flag name="F-ftree-ccp" class="optimization">
<![CDATA[
<p>Perform sparse conditional constant propagation (CCP) on trees. 
This pass only operates on local scalar variables and is 
enabled by default at -O and higher.  </p>
]]>
</flag>

<flag name="F-ftree-dce" class="optimization">
<![CDATA[
<p>Perform dead code elimination (DCE) on trees. 
This flag is enabled by default at -O and higher.  </p>
]]>
</flag>

<flag name="F-ftree-dominator-opts" class="optimization">
<![CDATA[
<p>Perform a variety of simple scalar cleanups (constant/copy propagation, 
redundancy elimination, range propagation and expression simplification) 
based on a dominator tree traversal. This also performs jump threading 
(to reduce jumps to jumps). This flag is enabled by default at -O and higher.  </p>
]]>
</flag>

<flag name="F-ftree-dse" class="optimization">
<![CDATA[
<p>Not described in Manual for gcc 4.1 </p>
]]>
</flag>

<flag name="F-ftree-ter" class="optimization">
<![CDATA[
<p>Perform temporary expression replacement during the SSA->normal phase. 
Single use/single def temporaries are replaced at their use location 
with their defining expression. This results in non-GIMPLE code, but 
gives the expanders much more complex trees to work on resulting in 
better RTL generation. This is enabled by default at -O and higher. </p>
]]>
</flag>

<flag name="F-ftree-lrs" class="optimization">
<![CDATA[
<p>Perform live range splitting during the SSA->normal phase. Distinct live ranges of a variable are split into unique variables, allowing for better optimization later. This is enabled by default at -O and higher. </p>
]]>
</flag>

<flag name="F-ftree-sra" class="optimization">
<![CDATA[
<p>Perform scalar replacement of aggregates. This pass replaces structure references with scalars to prevent committing structures to memory too early. This flag is enabled by default at -O and higher. </p>
]]>
</flag>

<flag name="F-ftree-copyrename" class="optimization">
<![CDATA[
<p>Perform copy renaming on trees. This pass attempts to rename compiler temporaries to other variables at copy locations, usually resulting in variable names which more closely resemble the original variables. This flag is enabled by default at -O and higher. </p>
]]>
</flag>

<flag name="F-ftree-fre" class="optimization">
<![CDATA[
<p>Perform Full Redundancy Elimination (FRE) on trees. The difference between FRE and PRE is that FRE only considers expressions that are computed on all paths leading to the redundant computation. This analysis faster than PRE, though it exposes fewer redundancies. This flag is enabled by default at -O and higher. </p>
]]>
</flag>

<flag name="F-ftree-ch" class="optimization">
<![CDATA[
<p>Perform loop header copying on trees. This is beneficial since it increases effectiveness of code motion optimizations. It also saves one jump. This flag is enabled by default at -O and higher. It is not enabled for -Os, since it usually increases code size. </p>
]]>
</flag>

<flag name="F-fmerge-constants" class="optimization">
<![CDATA[
<p>Attempt to merge identical constants (string constants and floating point constants) across compilation units.

This option is the default for optimized compilation if the assembler and linker support it. Use -fno-merge-constants to inhibit this behavior.

Enabled at levels -O, -O2, -O3, -Os.  </p>
]]>
</flag>

<flag name="F-fomit-frame-pointer" class="optimization">
<![CDATA[
<p>
Don't keep the frame pointer in a register for functions that don't need one. This avoids the instructions to save, set up and restore frame pointers; it also makes an extra register available in many functions. It also makes debugging impossible on some machines.

On some machines, such as the VAX, this flag has no effect, because the standard calling sequence automatically handles the frame pointer and nothing is saved by pretending it doesn't exist. The machine-description macro FRAME_POINTER_REQUIRED controls whether a target machine supports this flag. See Register Usage.

Enabled at levels -O, -O2, -O3, -Os.
</p>
]]>
</flag>

<flag name="F-fthread-jumps" class="optimization">
<![CDATA[
<p>
Perform optimizations where we check to see if a jump branches to a location where another comparison subsumed by the first is found. If so, the first branch is redirected to either the destination of the second branch or a point immediately following it, depending on whether the condition is known to be true or false.

Enabled at levels -O2, -O3, -Os. 
</p>
]]>
</flag>

<flag name="F-fcrossjumping" class="optimization">
<![CDATA[
<p>
Perform cross-jumping transformation. This transformation unifies equivalent code and save code size. The resulting code may or may not perform better than without cross-jumping.

Enabled at levels -O2, -O3, -Os. 
</p>
]]>
</flag>

<flag name="F-foptimize-sibling-calls" class="optimization">
<![CDATA[
<p>
Optimize sibling and tail recursive calls.

Enabled at levels -O2, -O3, -Os. 
</p>
]]>
</flag>

<flag name="F-fcse-follow-jumps" class="optimization">
<![CDATA[
<p>
In common subexpression elimination, scan through jump instructions when the target of the jump is not reached by any other path. For example, when CSE encounters an if statement with an else clause, CSE will follow the jump when the condition tested is false.

Enabled at levels -O2, -O3, -Os. 
</p>
]]>
</flag>

<flag name="F-fcse-skip-blocks" class="optimization">
<![CDATA[
<p>
This is similar to -fcse-follow-jumps, but causes CSE to follow jumps which conditionally skip over blocks. When CSE encounters a simple if statement with no else clause, -fcse-skip-blocks causes CSE to follow the jump around the body of the if.

Enabled at levels -O2, -O3, -Os.
</p>
]]>
</flag>

<flag name="F-fgcse" class="optimization">
<![CDATA[
<p>
Perform a global common subexpression elimination pass. This pass also performs global constant and copy propagation.

Note: When compiling a program using computed gotos, a GCC extension, you may get better runtime performance if you disable the global common subexpression elimination pass by adding -fno-gcse to the command line.

Enabled at levels -O2, -O3, -Os. 
    
</p>
]]>
</flag>

<flag name="F-fgcse-lm" class="optimization">
<![CDATA[
<p>
When -fgcse-lm is enabled, global common subexpression elimination will attempt to move loads which are only killed by stores into themselves. This allows a loop containing a load/store sequence to be changed to a load outside the loop, and a copy/store within the loop.

Enabled by default when gcse is enabled. 
    
</p>
]]>
</flag>

<flag name="F-fexpensive-optimizations" class="optimization">
<![CDATA[
<p>
Perform a number of minor optimizations that are relatively expensive.

Enabled at levels -O2, -O3, -Os. 
    
</p>
]]>
</flag>

<flag name="F-fstrength-reduce" class="optimization">
<![CDATA[
<p>
Perform the optimizations of loop strength reduction and elimination of iteration variables.

Enabled at levels -O2, -O3, -Os. 
    
</p>
]]>
</flag>

<flag name="F-frerun-loop-opt" class="optimization">
<![CDATA[
<p>
Run the loop optimizer twice.

Enabled at levels -O2, -O3, -Os. 
    
</p>
]]>
</flag>

<flag name="F-fcaller-saves" class="optimization">
<![CDATA[
<p>
Enable values to be allocated in registers that will be clobbered by function calls, by emitting extra instructions to save and restore the registers around such calls. Such allocation is done only when it seems to result in better code than would otherwise be produced.

This option is always enabled by default on certain machines, usually those which have no call-preserved registers to use instead.

Enabled at levels -O2, -O3, -Os. 
    
</p>
]]>
</flag>

<flag name="F-fpeephole2" class="optimization">
<![CDATA[
<p>
Disable any machine-specific peephole optimizations. The difference between -fno-peephole and -fno-peephole2 is in how they are implemented in the compiler; some targets use one, some use the other, a few use both.

-fpeephole is enabled by default. -fpeephole2 enabled at levels -O2, -O3, -Os. 
    
</p>
]]>
</flag>

<flag name="F-fschedule-insns" class="optimization">
<![CDATA[
<p>
If supported for the target machine, attempt to reorder instructions to eliminate execution stalls due to required data being unavailable. This helps machines that have slow floating point or memory load instructions by allowing other instructions to be issued until the result of the load or floating point instruction is required.

Enabled at levels -O2, -O3, -Os
    
</p>
]]>
</flag>

<flag name="F-fschedule-insns2" class="optimization">
<![CDATA[
<p>
Similar to -fschedule-insns, but requests an additional pass of instruction scheduling after register allocation has been done. This is especially useful on machines with a relatively small number of registers and where memory load instructions take more than one cycle.

Enabled at levels -O2, -O3, -Os. 
    
</p>
]]>
</flag>

<flag name="F-fnosched-interblock" class="optimization">
<![CDATA[
<p>
    Don't schedule instructions across basic blocks. This is normally enabled by default when scheduling before register allocation, i.e. with -fschedule-insns or at -O2 or higher.
</p>
]]>
</flag>

<flag name="F-fsched-spec" class="optimization">
<![CDATA[
<p>Don't allow speculative motion of non-load instructions. This is normally enabled by default when scheduling before register allocation, i.e. with -fschedule-insns or at -O2 or higher.
</p>
]]>
</flag>

<flag name="F-fregmove" class="optimization">
<![CDATA[
Attempt to reassign register numbers in move instructions and as operands of other simple instructions in order to maximize the amount of register tying. This is especially helpful on machines with two-operand instructions.

Note -fregmove and -foptimize-register-move are the same optimization.

Enabled at levels -O2, -O3, -Os.
<p>
</p>
]]>
</flag>


<flag name="F-fdelete-null-pointer-checks" class="optimization">
<![CDATA[
<p>
Use global dataflow analysis to identify and eliminate useless checks for null pointers. The compiler assumes that dereferencing a null pointer would have halted the program. If a pointer is checked after it has already been dereferenced, it cannot be null.

In some environments, this assumption is not true, and programs can safely dereference null pointers. Use -fno-delete-null-pointer-checks to disable this optimization for programs which depend on that behavior.

Enabled at levels -O2, -O3, -Os.
    
</p>
]]>
</flag>

<flag name="F-freorder-blocks" class="optimization">
<![CDATA[
<p>
Reorder basic blocks in the compiled function in order to reduce number of taken branches and improve code locality.

Enabled at levels -O2, -O3. 
    
</p>
]]>
</flag>

<flag name="F-freorder-functions" class="optimization">
<![CDATA[
<p>
Reorder functions in the object file in order to improve code locality. This is implemented by using special subsections .text.hot for most frequently executed functions and .text.unlikely for unlikely executed functions. Reordering is done by the linker so object file format must support named sections and linker must place them in a reasonable way.

Also profile feedback must be available in to make this option effective. See -fprofile-arcs for details.

Enabled at levels -O2, -O3, -Os.
    
</p>
]]>
</flag>

<flag name="F-funit-at-a-time" class="optimization">
<![CDATA[
<p>
Parse the whole compilation unit before starting to produce code. This allows some extra optimizations to take place but consumes more memory (in general). There are some compatibility issues with unit-at-at-time mode:

    * enabling unit-at-a-time mode may change the order in which functions, variables, and top-level asm statements are emitted, and will likely break code relying on some particular ordering. The majority of such top-level asm statements, though, can be replaced by section attributes.
    * unit-at-a-time mode removes unreferenced static variables and functions. This may result in undefined references when an asm statement refers directly to variables or functions that are otherwise unused. In that case either the variable/function shall be listed as an operand of the asm statement operand or, in the case of top-level asm statements the attribute used shall be used on the declaration.
    * Static functions now can use non-standard passing conventions that may break asm statements calling functions directly. Again, attribute used will prevent this behavior. 

As a temporary workaround, -fno-unit-at-a-time can be used, but this scheme may not be supported by future releases of GCC.

Enabled at levels -O2, -O3. 
    
</p>
]]>
</flag>

<flag name="F-falign-labels" class="optimization">
<![CDATA[
<p>
-falign-labels=n
    Align all branch targets to a power-of-two boundary, skipping up to n bytes like -falign-functions. This option can easily make code slower, because it must insert dummy operations for when the branch target is reached in the usual flow of the code.

    -fno-align-labels and -falign-labels=1 are equivalent and mean that labels will not be aligned.

    If -falign-loops or -falign-jumps are applicable and are greater than this value, then their values are used instead.

    If n is not specified or is zero, use a machine-dependent default which is very likely to be `1', meaning no alignment.

    Enabled at levels -O2, -O3. 
    
</p>
]]>
</flag>

<flag name="F-ftree-vrp" class="optimization">
<![CDATA[
<p>
Perform Value Range Propagation on trees. This is similar to the constant propagation pass, but instead of values, ranges of values are propagated. This allows the optimizers to remove unnecessary range checks like array bound checks and null pointer checks. This is enabled by default at -O2 and higher. Null pointer check elimination is only done if -fdelete-null-pointer-checks is enabled.    
</p>
]]>
</flag>

<flag name="F-ftree-pre" class="optimization">
<![CDATA[
<p>
Perform Partial Redundancy Elimination (PRE) on trees. This flag is enabled by default at -O2 and -O3. 
</p>
]]>
</flag>

<flag name="F-ffixed-form" class="other">
<![CDATA[
<p>Specify the layout used by the source file. Fixed form was traditionally used in older Fortran programs.
</p>
]]>
</flag>

<flag name="F-D" class="portability">
<example>
-D name,
-D name=definition
</example>
<![CDATA[
<p>The contents of definition are tokenized and processed as if they appeared during translation phase three in a ‘#define’ directive. In particular, the definition will be truncated by embedded newline characters.
If you are invoking the preprocessor from a shell or shell-like program you may need to use the shell's quoting syntax to protect characters such as spaces that have a meaning in the shell syntax.

If you wish to define a function-like macro on the command line, write its argument list with surrounding parentheses before the equals sign (if any). Parentheses are meaningful to most shells, so you will need to quote the option. With sh and csh, -D'name(args...)=definition' works.</p>
]]>
</flag>

<flag name="F-lm" class="portability">
<![CDATA[
<p>Link to the math library.</p>
]]>
</flag>

<flag name="F-frecord-marker" class="other">
<example>
-frecord-marker=length
</example>
<![CDATA[
<p>Specify the length of record markers for unformatted files. Valid values for length are 4 and 8. Default is 4. This is different from previous versions of gfortran, which specified a default record marker length of 8 on most systems. If you want to read or write files compatible with earlier versions of gfortran, use -frecord-marker=8.</p>
]]>
</flag>

<flag name="F-std" class="portability">
<example>
-std=version
</example>
<![CDATA[
<p>The compiler can accept several base standards, such as ‘c90’ or ‘c++98’, and GNU dialects of those standards, such as ‘gnu90’ or ‘gnu++98’. When a base standard is specified, the compiler accepts all programs following that standard plus those using GNU extensions that do not contradict it. For example, -std=c90 turns off certain features of GCC that are incompatible with ISO C90, such as the asm and typeof keywords, but not other GNU extensions that do not have a meaning in ISO C90, such as omitting the middle term of a ?: expression. On the other hand, when a GNU dialect of a standard is specified, all features supported by the compiler are enabled, even when those features change the meaning of the base standard. As a result, some strict-conforming programs may be rejected. The particular standard is used by -Wpedantic to identify which features are GNU extensions given that version of the standard. For example -std=gnu90 -Wpedantic warns about C++ style ‘//’ comments, while -std=gnu99 -Wpedantic does not.</p>

<p>A value for this option must be provided; possible values are:</p>

<ul>
<li>c90</li>
<li>c89</li>
<li>c99</li>
<li>c9x</li>
<li>c11</li>
<li>c1x</li>
<li>gnu90</li>
<li>gnu89</li>
<li>gnu99</li>
<li>gnu9x</li>
<li>gnu11</li>
<li>gnu1x</li>
<li>c++98</li>
<li>c++03</li>
<li>gnu++98</li>
<li>gnu++03</li>
<li>c++11</li>
<li>c++0x</li>
<li>gnu++11</li>
<li>gnu++0x</li>
</ul>
]]>
</flag>

<flag name="F-mabi" class="optimization">
<example>
-mabi=name
</example>
<![CDATA[
<p>Generate code for the specified data model. Permissible values are ‘ilp32’ for SysV-like data model where int, long int and pointer are 32-bit, and ‘lp64’ for SysV-like data model where int is 32-bit, but long int and pointer are 64-bit.
The default depends on the specific target configuration. Note that the LP64 and ILP32 ABIs are not link-compatible; you must compile your entire program with the same ABI, and link with a compatible set of libraries.</p>
]]>
</flag>

<flag name="F-fno-aggressive-loop-optimizations" class="other">
<![CDATA[
<p>Disable this aggressive analysis.</p>
]]>
</flag>

<flag name="F-flto" class="optimization">
<example>
-flto,
-flto=n
</example>
<![CDATA[
<p>This option runs the standard link-time optimizer. When invoked with source code, it generates GIMPLE (one of GCC's internal representations) and writes it to special ELF sections in the object file. When the object files are linked together, all the function bodies are read from these ELF sections and instantiated as if they had been part of the same translation unit.</p>
]]>
</flag>

<flag name="F-fprofile-generate" class="optimization">
<![CDATA[
<p>Will instrument the application with profiling code for use by ‘-fprofile-use’.
</p>
]]>
</flag>

<flag name="F-fprofile-use" class="optimization">
<example>
-fprofile-use,
-fprofile-use=path
</example>
<![CDATA[
<p>Enable profile feedback-directed optimizations, and the following optimizations which are generally profitable only with profile feedback available.
</p>
]]>
</flag>

<flag name="F-fno-protect-parens" class="optimization">
<![CDATA[
<p>By default the parentheses in expression are honored for all optimization levels such that the compiler does not do any re-association. Using -fno-protect-parens allows the compiler to reorder REAL and COMPLEX expressions to produce faster code. Note that for the re-association optimization -fno-signed-zeros and -fno-trapping-math need to be in effect. The parentheses protection is enabled by default, unless -Ofast is given.</p>
]]>
</flag>

<flag name="F-fstack-arrays" class="optimization">
<![CDATA[
<p>Adding this option will make the Fortran compiler put all local arrays, even those of unknown size onto stack memory. If your program uses very large local arrays it is possible that you will have to extend your runtime limits for stack memory on some operating systems. This flag is enabled by default at optimization level -Ofast. </p>
]]>
</flag>

<!-- This ends the fun. -->
</flagsdescription>
